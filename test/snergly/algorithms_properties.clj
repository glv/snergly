(ns snergly.algorithms-properties
  (:import (clojure.lang PersistentQueue))
  (:require [clojure.test :refer :all]
            [clojure.test.check.generators :as gen]
            [clojure.test.check.properties :as prop]
            [clojure.test.check.clojure-test :refer :all]
            [clojure.core.async :as async]
            [clojure.set :as set]
            [schema.test]
            [snergly.algorithms :refer :all]
            [snergly.grid :as grid]))

;; This seems like a perfect application for property-based testing.  There's
;; no way to inspect a maze and prove that it was generated by a correct
;; implementation of, say, Wilson's algorithm.  And the inherent randomness of
;; the algorithms means that any particular example I come up with might not
;; expose all of the issues.
;;
;; But we do know that all of these algorithms are supposed to produce
;; "perfect" mazes (fully connected, no loops).  And I know that I want them
;; all to report intermediate results for animation purposes according to
;; particular rules.
;;
;; So if I can find a way to validate that the final maze is a perfect maze,
;; then I can have a fair degree of confidence that an implementation that
;; seems (from inspection) to correctly implement the algorithm is, in fact,
;; correct, because nearly all bugs would either disrupt that property or cause
;; a crash or non-termination.  (A bug that didn't do any of those things would
;; actually mean it was a different algorithm.)
;;
;; And if I can find a way to validate that the intermediate results are
;; reported according to my rules, then I can be confident that the animations
;; are correct.

(use-fixtures :once schema.test/validate-schemas)

;; -----------------------------------------------------------------------------
;; Generators

(def gen-dimen
  (gen/fmap inc gen/s-pos-int))

(def gen-grid
  (gen/fmap #(apply grid/make-grid %) (gen/vector gen-dimen 2)))

(def gen-grid-and-coord
  (gen/bind gen-grid
            (fn [grid] (gen/tuple (gen/return grid)
                                  (gen/tuple
                                    (gen/choose 0 (dec (:rows grid)))
                                    (gen/choose 0 (dec (:columns grid)))
                                    )))))

(def gen-maze-and-coord
  (gen/bind gen-grid
            (fn [grid] (gen/tuple (gen/return ((synchronous-fn (algorithm-functions "binary-tree")) grid))
                                  (gen/tuple
                                    (gen/choose 0 (dec (:rows grid)))
                                    (gen/choose 0 (dec (:columns grid))))))))

;; -----------------------------------------------------------------------------
;; Utility and validation functions

(defn grid-cells [g]
  (map #(grid/grid-cell g %) (grid/grid-coords g)))

(defn new-grid?
  [grid]
  (and (grid/new? grid)
       (every? empty?
               (map #(:links (grid/grid-cell grid %)) (grid/grid-coords grid)))))

(defn has-cycle?
  ([grid] (has-cycle? grid [0 0]))
  ([grid start]
   (loop [[current-coord parent] [start nil]
          frontier PersistentQueue/EMPTY
          visited #{}]
     (cond
       (nil? current-coord) false
       (contains? visited current-coord) true
       :else (let [cell (grid/grid-cell grid current-coord)
                   links (remove #(= parent %) (:links cell))
                   next-frontier (apply conj frontier (map #(vector % current-coord) links))]
               (recur (peek next-frontier)
                      (pop next-frontier)
                      (conj visited current-coord)))))))

(defn actual-change-sets [grids]
  (letfn [(link-set [g coord]
            (set (:links (grid/grid-cell g coord))))
          (cell-changed? [a b coord]
            (not= (link-set a coord) (link-set b coord)))
          (changed-cells [[a b]]
            {:pre [(and (= (:rows a) (:rows b))
                        (= (:columns a) (:columns b)))]}
            (set (filter (partial cell-changed? a b) (grid/grid-coords a))))]
    (map changed-cells (partition 2 (interleave grids (rest grids))))))

;; -----------------------------------------------------------------------------
;; Capturing asynchronous updates

(defn all-updates [algorithm-fn]
  (let [intermediate-chan (async/chan)
        result-chan (algorithm-fn intermediate-chan)]
    (async/<!! (async/go-loop [grids []]
                 (if-let [g (async/<! intermediate-chan)]
                   (recur (conj grids g))
                   (conj grids (async/<! result-chan)))))))

(defn final-update [algorithm-fn]
  (let [intermediate-chan (async/chan)
        result-chan (algorithm-fn intermediate-chan)]
    (async/<!! (async/go-loop []
                 (if (async/<! intermediate-chan)
                   (recur)
                   (async/<! result-chan))))))

;; -----------------------------------------------------------------------------
;; Property definitions for maze algorithms

;; In these definitions, some names are used consistently to help make
;; things clearer.
;;
;; * the word "final" refers to the final grid (the one that is the return
;;   value from the algorithm)
;; * the word "update" refers to all grids.  Each update is supposed to
;;   include changes (because there's no sense supplying them for animation
;;   unless they've changed).
;; * the word "incomplete" refers to all of the updates *prior* to the final
;;   grid.

;; Is the final grid a perfect maze?
(defmacro check-algorithm-perfect-maze [alg-name]
  `(defspec ~(symbol (str alg-name "-produces-a-perfect-maze"))
     5
     (prop/for-all [grid# gen-grid]
       (let [final# (final-update (partial (algorithm-functions "binary-tree") grid#))
             links# (map :links (grid-cells final#))
             distances# ((synchronous-fn find-distances) final# [0 0])
             ]
         (every? not-empty links#)                    ; quick check for no isolated cells
         (every? #(contains? distances# %) (grid/grid-coords final#)) ; every cell reachable
         (not (has-cycle? final#))                    ; no cycles
         ))))

;; Is every cell eventually changed?
(defmacro check-algorithm-all-cells-changed [alg-name]
  `(defspec ~(symbol (str alg-name "-all-cells-changed"))
     10
     (prop/for-all [grid# gen-grid]
       (let [updates# (all-updates (partial (algorithm-functions ~alg-name) grid#))
             change-sets# (filter identity (map :changed-cells updates#))
             changed-cells# (apply set/union change-sets#)]
         (= (set (grid/grid-coords grid#)) changed-cells#)))))

;; Do all updates actually change the grid?
(defmacro check-algorithm-each-update-changes [alg-name]
  `(defspec ~(symbol (str alg-name "-each-update-changes"))
     5
     (prop/for-all [grid# gen-grid]
       (let [updates# (all-updates (partial (algorithm-functions ~alg-name) grid#))
             change-sets# (map :changed-cells updates#)]
         (every? not-empty change-sets#)))))

;; Do all incompletes actually change the grid?
;; (A looser version of each-update-changes allowing a redundant final update)
(defmacro check-algorithm-each-incomplete-changes [alg-name]
  `(defspec ~(symbol (str alg-name "-each-incomplete-changes"))
     5
     (prop/for-all [grid# gen-grid]
       (let [incompletes# (butlast (all-updates (partial (algorithm-functions ~alg-name) grid#)))
             change-sets# (map :changed-cells incompletes#)]
         (every? not-empty change-sets#)))))

;; Does each update link exactly two cells?
(defmacro check-algorithm-updates-link-2 [alg-name]
  `(defspec ~(symbol (str alg-name "-links-two-cells-each-update"))
     5
     (prop/for-all [grid# gen-grid]
       (let [updates# (all-updates (partial (algorithm-functions ~alg-name) grid#))
             update-change-sets# (map :changed-cells updates#)]
         (every? (fn [cs#] (= 2 (count cs#)))
                 update-change-sets#)))))

;; Does each incomplete link exactly two cells?
;; (A looser version of updates-link-2 allowing a redundant final update)
(defmacro check-algorithm-incompletes-link-2 [alg-name]
  `(defspec ~(symbol (str alg-name "-links-two-cells-each-incomplete"))
     5
     (prop/for-all [grid# gen-grid]
       (let [incompletes# (butlast (all-updates (partial (algorithm-functions ~alg-name) grid#)))
             incomplete-change-sets# (map :changed-cells incompletes#)]
         (every? (fn [cs#] (= 2 (count cs#)))
                 incomplete-change-sets#)))))

;; Is each update's :changed-cells set accurate?
(defmacro check-algorithm-cells-changed-is-accurate [alg-name]
  `(defspec ~(symbol (str alg-name "-cells-changed-is-accurate"))
     5
     (prop/for-all [grid# gen-grid]
       (let [updates# (all-updates (partial (algorithm-functions ~alg-name) grid#))
             update-change-sets# (map :changed-cells updates#)
             actual-change-sets# (actual-change-sets (cons grid# updates#))]
         (every? (fn [[a# c#]] (= a# c#)) (partition 2 (interleave actual-change-sets# update-change-sets#)))))))

(defmacro check-algorithm-properties
  [alg-name & specs]

  (let [specs (cond
                (empty? specs)     #{:perfect :all-changed :accurate-changes :each-update-changes :updates-link-2}
                (= [:loose] specs) #{:perfect :all-changed :accurate-changes :each-incomplete-changes :incompletes-link-2}
                :else              (set specs))]
    `(do
       (when (contains? ~specs :perfect)
         (check-algorithm-perfect-maze ~alg-name))

       (when (contains? ~specs :all-changed)
         (check-algorithm-all-cells-changed ~alg-name))

       (when (contains? ~specs :each-update-changes)
         (check-algorithm-each-update-changes ~alg-name))

       (when (contains? ~specs :each-incomplete-changes)
         (check-algorithm-each-incomplete-changes ~alg-name))

       (when (contains? ~specs :updates-link-2)
         (check-algorithm-updates-link-2 ~alg-name))

       (when (contains? ~specs :incompletes-link-2)
         (check-algorithm-incompletes-link-2 ~alg-name))

       (when (contains? ~specs :accurate-changes)
         (check-algorithm-cells-changed-is-accurate ~alg-name))

       )
    ))

;; -----------------------------------------------------------------------------
;; Checking the algorithms

(check-algorithm-properties "binary-tree")
(check-algorithm-properties "sidewinder")
(check-algorithm-properties "wilsons")
(check-algorithm-properties "aldous-broder")
;; The following can't pass :each-changes because the last update might be a duplicate.
(check-algorithm-properties "hunt-and-kill" :loose)
(check-algorithm-properties "recursive-backtracker" :loose)

;; -----------------------------------------------------------------------------
;; Properties for analysis algorithms

;; What kinds of properties can I assert about find-distances?
;;
;; * Each cell is changed exactly once (done)
;; * :max always increases by 1 (starting with 1)
;; * Each step, every changed cell has distance :max
;; * (maybe) if no intermediate-chan, the result grid shows all cells changed
;;
;; Do I need to run these properties against mazes generated by all of the
;; different algorithms?  I would say not, because if they're all perfect
;; mazes, the biases etc. in the mazes won't make a difference.

(defspec find-distances-changes-each-cell-exactly-once
  10
  (prop/for-all [[grid start-coord] gen-grid-and-coord]
    (let [maze (final-update (partial (algorithm-functions "binary-tree") grid))
          updates (all-updates (partial find-distances maze start-coord))
          change-sets (filter identity (map :changed-cells updates))
          change-appearances (conj (apply concat change-sets) start-coord)
          change-counts (group-by identity change-appearances)]
      (every? #(= 1 (count %)) (vals change-counts))
      (= (set (grid/grid-coords grid))
         (set (keys change-counts))))))

(defspec find-distances-each-intermediate-changes
  5
  (prop/for-all [[grid start-coord] gen-grid-and-coord]
    (let [maze (final-update (partial (algorithm-functions "binary-tree") grid))
          intermediates (butlast (all-updates (partial find-distances maze start-coord)))
          change-sets (map :changed-cells intermediates)]
      (every? not-empty change-sets))))

;;; I thought this was failing just because there's a redundant update at the
;;; end.  But no ... filtered that out, and apparently sometimes max increases
;;; by 2.
;(defspec find-distances-max-advances-by-1
;  10
;  (prop/for-all [[maze start-coord] gen-maze-and-coord]
;    (let [intermediates (butlast (all-updates (partial find-distances maze start-coord)))
;          maxes (map :max intermediates)
;          diffs (map (fn [[a b]] (- b a)) (partition 2 (interleave maxes (rest maxes))))]
;      (println (str "maxes: " (vec maxes)))
;      (println (str "diffs: " (vec diffs)))
;      (every? #(= 1 %)
;              (map (fn [[a b]] (- b a)) (partition 2 (interleave maxes (rest maxes))))))))

;; Both of the following mazes, with start coordinate [0 0], cause
;; find-distances to report :max values [1 2 3 4 5 7], skipping 6.
;; Note that in both cases, the two changed cells are linked to each other,
;; so that they can't have the same distance.  This makes me think we're
;; missing a begin-step somewhere.

(comment
  {:type :Grid
   :algorithm-name "binary-tree"
   :rows 5
   :columns 3
   :cells [{:type :Cell, :coord [0 0], :north nil, :south [1 0], :east [0 1], :west nil, :links #{[1 0] [0 1]}}
           {:type :Cell, :coord [0 1], :north nil, :south [1 1], :east [0 2], :west [0 0], :links #{[0 0] [0 2]}}
           {:type :Cell, :coord [0 2], :north nil, :south [1 2], :east nil, :west [0 1], :links #{[1 2] [0 1]}}
           {:type :Cell, :coord [1 0], :north [0 0], :south [2 0], :east [1 1], :west nil, :links #{[0 0] [2 0]}}
           {:type :Cell, :coord [1 1], :north [0 1], :south [2 1], :east [1 2], :west [1 0], :links #{[2 1] [1 2]}}
           {:type :Cell, :coord [1 2], :north [0 2], :south [2 2], :east nil, :west [1 1], :links #{[2 2] [1 1] [0 2]}}
           {:type :Cell, :coord [2 0], :north [1 0], :south [3 0], :east [2 1], :west nil, :links #{[1 0]}}
           {:type :Cell, :coord [2 1], :north [1 1], :south [3 1], :east [2 2], :west [2 0], :links #{[1 1]}}
           {:type :Cell, :coord [2 2], :north [1 2], :south [3 2], :east nil, :west [2 1], :links #{[1 2] [3 2]}}
           {:type :Cell, :coord [3 0], :north [2 0], :south [4 0], :east [3 1], :west nil, :links #{[3 1] [4 0]}}
           {:type :Cell, :coord [3 1], :north [2 1], :south [4 1], :east [3 2], :west [3 0], :links #{[3 0] [4 1] [3 2]}}
           {:type :Cell, :coord [3 2], :north [2 2], :south [4 2], :east nil, :west [3 1], :links #{[2 2] [4 2] [3 1]}}
           {:type :Cell, :coord [4 0], :north [3 0], :south nil, :east [4 1], :west nil, :links #{[3 0]}}
           {:type :Cell, :coord [4 1], :north [3 1], :south nil, :east [4 2], :west [4 0], :links #{[3 1]}}
           {:type :Cell, :coord [4 2], :north [3 2], :south nil, :east nil, :west [4 1], :links #{[3 2]}}
           ]
   :changed-cells #{[4 2] [3 2]}
   }
  ;; +---+---+---+
  ;; |           |
  ;; +   +---+   +
  ;; |   |       |
  ;; +   +   +   +
  ;; |   |   |   |
  ;; +---+---+   +
  ;; |           |
  ;; +   +   +   +
  ;; |   |   |   |
  ;; +---+---+---+

  {:type :Grid
   :algorithm-name "binary-tree"
   :rows 4
   :columns 3
   :cells [{:type :Cell, :coord [0 0], :north nil, :south [1 0], :east [0 1], :west nil, :links #{[1 0] [0 1]}}
           {:type :Cell, :coord [0 1], :north nil, :south [1 1], :east [0 2], :west [0 0], :links #{[0 0] [1 1] [0 2]}}
           {:type :Cell, :coord [0 2], :north nil, :south [1 2], :east nil, :west [0 1], :links #{[1 2] [0 1]}}
           {:type :Cell, :coord [1 0], :north [0 0], :south [2 0], :east [1 1], :west nil, :links #{[0 0]}}
           {:type :Cell, :coord [1 1], :north [0 1], :south [2 1], :east [1 2], :west [1 0], :links #{[0 1]}}
           {:type :Cell, :coord [1 2], :north [0 2], :south [2 2], :east nil, :west [1 1], :links #{[2 2] [0 2]}}
           {:type :Cell, :coord [2 0], :north [1 0], :south [3 0], :east [2 1], :west nil, :links #{[2 1]}}
           {:type :Cell, :coord [2 1], :north [1 1], :south [3 1], :east [2 2], :west [2 0], :links #{[2 2] [2 0] [3 1]}}
           {:type :Cell, :coord [2 2], :north [1 2], :south [3 2], :east nil, :west [2 1], :links #{[2 1] [1 2] [3 2]}}
           {:type :Cell, :coord [3 0], :north [2 0], :south nil, :east [3 1], :west nil, :links #{[3 1]}}
           {:type :Cell, :coord [3 1], :north [2 1], :south nil, :east [3 2], :west [3 0], :links #{[3 0] [2 1]}}
           {:type :Cell, :coord [3 2], :north [2 2], :south nil, :east nil, :west [3 1], :links #{[2 2]}}
           ]
   :changed-cells #{[2 2] [3 2]}
   }
  ;; +---+---+---+
  ;; |           |
  ;; +   +   +   +
  ;; |   |   |   |
  ;; +---+---+   +
  ;; |           |
  ;; +---+   +   +
  ;; |       |   |
  ;; +---+---+---+

  )
;; Analyzed by ClojureScript 1.7.170
{:use-macros nil, :excludes #{}, :name schema.spec.variant, :imports nil, :requires {utils schema.utils, schema.utils schema.utils, spec schema.spec.core, schema.spec.core schema.spec.core}, :uses nil, :defs {option-step {:protocol-inline nil, :meta {:file "/Users/glv/Projects/snergly/resources/public/js/schema/spec/variant.cljs", :line 12, :column 8, :end-line 12, :end-column 19, :private true, :arglists (quote ([o params else]))}, :private true, :name schema.spec.variant/option-step, :variadic false, :file "resources/public/js/schema/spec/variant.cljs", :end-column 19, :method-params ([o params else]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 12, :end-line 12, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o params else]))}, VariantSpec {:num-fields 4, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted schema.spec.core/CoreSpec cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name schema.spec.variant/VariantSpec, :file "resources/public/js/schema/spec/variant.cljs", :end-column 23, :type true, :column 12, :internal-ctor true, :line 41, :record true, :end-line 41, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, ->VariantSpec {:protocol-inline nil, :meta {:file "/Users/glv/Projects/snergly/resources/public/js/schema/spec/variant.cljs", :line 41, :column 12, :end-line 41, :end-column 23, :internal-ctor true, :factory :positional, :arglists (quote ([pre options err-f post]))}, :name schema.spec.variant/->VariantSpec, :variadic false, :file "resources/public/js/schema/spec/variant.cljs", :end-column 23, :method-params ([pre options err-f post]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 41, :end-line 41, :max-fixed-arity 4, :fn-var true, :arglists (quote ([pre options err-f post]))}, map->VariantSpec {:protocol-inline nil, :meta {:file "/Users/glv/Projects/snergly/resources/public/js/schema/spec/variant.cljs", :line 41, :column 12, :end-line 41, :end-column 23, :internal-ctor true, :factory :map, :arglists (quote ([G__18337]))}, :name schema.spec.variant/map->VariantSpec, :variadic false, :file "resources/public/js/schema/spec/variant.cljs", :end-column 23, :method-params ([G__18337]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 41, :end-line 41, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__18337]))}, variant-spec {:protocol-inline nil, :meta {:file "/Users/glv/Projects/snergly/resources/public/js/schema/spec/variant.cljs", :line 61, :column 7, :end-line 61, :end-column 19, :arglists (quote ([pre options] [pre options err-f] [pre options err-f post])), :doc "A variant spec represents a choice between a set of alternative\n   subschemas, e.g., a tagged union. It has an overall precondition,\n   set of options, and error function.\n\n   The semantics of `options` is that the options are processed in\n   order. During checking, the datum must match the schema for the\n   first option for which `guard` passes. During generation, any datum\n   generated from an option will pass the corresponding `guard`.\n\n   err-f is a function to produce an error message if none\n   of the guards match (and must be passed unless the last option has no\n   guard).", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([pre options] [pre options err-f] [pre options err-f post]), :arglists ([pre options] [pre options err-f] [pre options err-f post]), :arglists-meta (nil nil nil)}}, :name schema.spec.variant/variant-spec, :variadic false, :file "resources/public/js/schema/spec/variant.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([pre options] [pre options err-f] [pre options err-f post]), :arglists ([pre options] [pre options err-f] [pre options err-f post]), :arglists-meta (nil nil nil)}, :method-params ([pre options] [pre options err-f] [pre options err-f post]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 61, :end-line 61, :max-fixed-arity 4, :fn-var true, :arglists ([pre options] [pre options err-f] [pre options err-f post]), :doc "A variant spec represents a choice between a set of alternative\n   subschemas, e.g., a tagged union. It has an overall precondition,\n   set of options, and error function.\n\n   The semantics of `options` is that the options are processed in\n   order. During checking, the datum must match the schema for the\n   first option for which `guard` passes. During generation, any datum\n   generated from an option will pass the corresponding `guard`.\n\n   err-f is a function to produce an error message if none\n   of the guards match (and must be passed unless the last option has no\n   guard)."}}, :require-macros {macros schema.macros, schema.macros schema.macros, utils schema.utils, schema.utils schema.utils}, :cljs.analyzer/constants {:seen #{options :schema :return-walked? throws? :pre :else :wrap-error pre :err-f err-f :schema.spec.variant/exception :post :options :guard post}, :order [:guard :schema.spec.variant/exception :else :schema throws? :wrap-error :return-walked? :pre :options :err-f :post pre options err-f post]}, :doc nil}